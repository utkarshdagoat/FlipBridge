{"version":3,"file":"router-sdk.cjs.development.js","sources":["../src/constants.ts","../src/approveAndCall.ts","../src/multicallExtended.ts","../src/paymentsExtended.ts","../src/entities/mixedRoute/route.ts","../src/entities/mixedRoute/trade.ts","../src/entities/protocol.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/utils/encodeMixedRouteToPath.ts","../src/utils/index.ts","../src/swapRouter.ts"],"sourcesContent":["import { Percent } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\n\nexport const MSG_SENDER = '0x0000000000000000000000000000000000000001'\nexport const ADDRESS_THIS = '0x0000000000000000000000000000000000000002'\n\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n\n// = 1 << 23 or 100000000000000000000000\nexport const V2_FEE_PATH_PLACEHOLDER = 8388608\n\nexport const ZERO_PERCENT = new Percent(ZERO)\nexport const ONE_HUNDRED_PERCENT = new Percent(100, 100)\n","import { Interface } from '@ethersproject/abi'\nimport invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json'\nimport { Currency, Percent, Token } from '@uniswap/sdk-core'\nimport {\n  MintSpecificOptions,\n  IncreaseSpecificOptions,\n  NonfungiblePositionManager,\n  Position,\n  toHex,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\n// condensed version of v3-sdk AddLiquidityOptions containing only necessary swap + add attributes\nexport type CondensedAddLiquidityOptions = Omit<MintSpecificOptions, 'createPool'> | IncreaseSpecificOptions\n\nexport enum ApprovalTypes {\n  NOT_REQUIRED = 0,\n  MAX = 1,\n  MAX_MINUS_ONE = 2,\n  ZERO_THEN_MAX = 3,\n  ZERO_THEN_MAX_MINUS_ONE = 4,\n}\n\n// type guard\nexport function isMint(options: CondensedAddLiquidityOptions): options is Omit<MintSpecificOptions, 'createPool'> {\n  return Object.keys(options).some((k) => k === 'recipient')\n}\n\nexport abstract class ApproveAndCall {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeApproveMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address])\n  }\n\n  public static encodeApproveMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address])\n  }\n\n  public static encodeApproveZeroThenMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address])\n  }\n\n  public static encodeApproveZeroThenMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address])\n  }\n\n  public static encodeCallPositionManager(calldatas: string[]): string {\n    invariant(calldatas.length > 0, 'NULL_CALLDATA')\n\n    if (calldatas.length === 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas)\n    } else {\n      const encodedMulticall = NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas])\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall])\n    }\n  }\n  /**\n   * Encode adding liquidity to a position in the nft manager contract\n   * @param position Forcasted position with expected amount out from swap\n   * @param minimalPosition Forcasted position with custom minimal token amounts\n   * @param addLiquidityOptions Options for adding liquidity\n   * @param slippageTolerance Defines maximum slippage\n   */\n  public static encodeAddLiquidity(\n    position: Position,\n    minimalPosition: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    slippageTolerance: Percent\n  ): string {\n    let { amount0: amount0Min, amount1: amount1Min } = position.mintAmountsWithSlippage(slippageTolerance)\n\n    // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          fee: position.pool.fee,\n          tickLower: position.tickLower,\n          tickUpper: position.tickUpper,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          recipient: addLiquidityOptions.recipient,\n        },\n      ])\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          tokenId: toHex(addLiquidityOptions.tokenId),\n        },\n      ])\n    }\n  }\n\n  public static encodeApprove(token: Currency, approvalType: ApprovalTypes): string {\n    switch (approvalType) {\n      case ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped)\n      case ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped)\n      default:\n        throw new Error('Error: invalid ApprovalType')\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json'\nimport { Multicall, toHex } from '@uniswap/v3-sdk'\n\n// deadline or previousBlockhash\nexport type Validation = BigintIsh | string\n\nfunction validateAndParseBytes32(bytes32: string): string {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(`${bytes32} is not valid bytes32.`)\n  }\n\n  return bytes32.toLowerCase()\n}\n\nexport abstract class MulticallExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeMulticall(calldatas: string | string[], validation?: Validation): string {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return Multicall.encodeMulticall(calldatas)\n    }\n\n    // if there is validation, we have to normalize calldatas\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas]\n    }\n\n    // this means the validation value should be a previousBlockhash\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      const previousBlockhash = validateAndParseBytes32(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [\n        previousBlockhash,\n        calldatas,\n      ])\n    } else {\n      const deadline = toHex(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas])\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Percent, Token, validateAndParseAddress } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json'\nimport { FeeOptions, Payments, toHex } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nfunction encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n\nexport abstract class PaymentsExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeUnwrapWETH9(amountMinimum: JSBI, recipient?: string, feeOptions?: FeeOptions): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [toHex(amountMinimum)])\n    }\n  }\n\n  public static encodeSweepToken(\n    token: Token,\n    amountMinimum: JSBI,\n    recipient?: string,\n    feeOptions?: FeeOptions\n  ): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [\n        token.address,\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [\n        token.address,\n        toHex(amountMinimum),\n      ])\n    }\n  }\n\n  public static encodePull(token: Token, amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, toHex(amount)])\n  }\n\n  public static encodeWrapETH(amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [toHex(amount)])\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { Pool } from '@uniswap/v3-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\n\ntype TPool = Pair | Pool\n\n/**\n * Represents a list of pools or pairs through which a swap can occur\n * @template TInput The input token\n * @template TOutput The output token\n */\nexport class MixedRouteSDK<TInput extends Currency, TOutput extends Currency> {\n  public readonly pools: TPool[]\n  public readonly path: Token[]\n  public readonly input: TInput\n  public readonly output: TOutput\n\n  private _midPrice: Price<TInput, TOutput> | null = null\n\n  /**\n   * Creates an instance of route.\n   * @param pools An array of `TPool` objects (pools or pairs), ordered by the route the swap will take\n   * @param input The input token\n   * @param output The output token\n   */\n  public constructor(pools: TPool[], input: TInput, output: TOutput) {\n    invariant(pools.length > 0, 'POOLS')\n\n    const chainId = pools[0].chainId\n    const allOnSameChain = pools.every((pool) => pool.chainId === chainId)\n    invariant(allOnSameChain, 'CHAIN_IDS')\n\n    const wrappedInput = input.wrapped\n    invariant(pools[0].involvesToken(wrappedInput), 'INPUT')\n\n    invariant(pools[pools.length - 1].involvesToken(output.wrapped), 'OUTPUT')\n\n    /**\n     * Normalizes token0-token1 order and selects the next token/fee step to add to the path\n     * */\n    const tokenPath: Token[] = [wrappedInput]\n    for (const [i, pool] of pools.entries()) {\n      const currentInputToken = tokenPath[i]\n      invariant(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1), 'PATH')\n      const nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0\n      tokenPath.push(nextToken)\n    }\n\n    this.pools = pools\n    this.path = tokenPath\n    this.input = input\n    this.output = output ?? tokenPath[tokenPath.length - 1]\n  }\n\n  public get chainId(): number {\n    return this.pools[0].chainId\n  }\n\n  /**\n   * Returns the mid price of the route\n   */\n  public get midPrice(): Price<TInput, TOutput> {\n    if (this._midPrice !== null) return this._midPrice\n\n    const price = this.pools.slice(1).reduce(\n      ({ nextInput, price }, pool) => {\n        return nextInput.equals(pool.token0)\n          ? {\n              nextInput: pool.token1,\n              price: price.multiply(pool.token0Price),\n            }\n          : {\n              nextInput: pool.token0,\n              price: price.multiply(pool.token1Price),\n            }\n      },\n      this.pools[0].token0.equals(this.input.wrapped)\n        ? {\n            nextInput: this.pools[0].token1,\n            price: this.pools[0].token0Price,\n          }\n        : {\n            nextInput: this.pools[0].token0,\n            price: this.pools[0].token1Price,\n          }\n    ).price\n\n    return (this._midPrice = new Price(this.input, this.output, price.denominator, price.numerator))\n  }\n}\n","import { Currency, Fraction, Percent, Price, sortedInsert, CurrencyAmount, TradeType, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { BestTradeOptions, Pool } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../../constants'\nimport { MixedRouteSDK } from './route'\n\n/**\n * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n * @param a The first trade to compare\n * @param b The second trade to compare\n * @returns A sorted ordering for two neighboring elements in a trade array\n */\nexport function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n  a: MixedRouteTrade<TInput, TOutput, TTradeType>,\n  b: MixedRouteTrade<TInput, TOutput, TTradeType>\n) {\n  // must have same input and output token for comparison\n  invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      // consider the number of hops since each hop costs gas\n      const aHops = a.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      const bHops = b.swaps.reduce((total, cur) => total + cur.route.path.length, 0)\n      return aHops - bHops\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n/**\n * Represents a trade executed against a set of routes where some percentage of the input is\n * split across each route.\n *\n * Each route has its own set of pools. Pools can not be re-used across routes.\n *\n * Does not account for slippage, i.e., changes in price environment that can occur between\n * the time the trade is submitted and when it is executed.\n * @notice This class is functionally the same as the `Trade` class in the `@uniswap/v3-sdk` package, aside from typing and some input validation.\n * @template TInput The input token, either Ether or an ERC-20\n * @template TOutput The output token, either Ether or an ERC-20\n * @template TTradeType The trade type, either exact input or exact output\n */\nexport class MixedRouteTrade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  /**\n   * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes\n   * this will return an error.\n   *\n   * When the trade consists of just a single route, this returns the route of the trade,\n   * i.e. which pools the trade goes through.\n   */\n  public get route(): MixedRouteSDK<TInput, TOutput> {\n    invariant(this.swaps.length === 1, 'MULTIPLE_ROUTES')\n    return this.swaps[0].route\n  }\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade.\n   */\n  public readonly swaps: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TTradeType\n\n  /**\n   * The cached result of the input amount computation\n   * @private\n   */\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  /**\n   * The cached result of the output amount computation\n   * @private\n   */\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  /**\n   * The cached result of the computed execution price\n   * @private\n   */\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Constructs a trade by simulating swaps through the given route\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param route route to swap through\n   * @param amount the amount specified, either input or output, depending on tradeType\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The route\n   */\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const amounts: CurrencyAmount<Token>[] = new Array(route.path.length)\n    let inputAmount: CurrencyAmount<TInput>\n    let outputAmount: CurrencyAmount<TOutput>\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    invariant(amount.currency.equals(route.input), 'INPUT')\n    amounts[0] = amount.wrapped\n    for (let i = 0; i < route.path.length - 1; i++) {\n      const pool = route.pools[i]\n      const [outputAmount] = await pool.getOutputAmount(amounts[i])\n      amounts[i + 1] = outputAmount\n    }\n    inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n    outputAmount = CurrencyAmount.fromFractionalAmount(\n      route.output,\n      amounts[amounts.length - 1].numerator,\n      amounts[amounts.length - 1].denominator\n    )\n\n    return new MixedRouteTrade({\n      routes: [{ inputAmount, outputAmount, route }],\n      tradeType,\n    })\n  }\n\n  /**\n   * Constructs a trade from routes by simulating swaps\n   *\n   * @template TInput The input token, either Ether or an ERC-20.\n   * @template TOutput The output token, either Ether or an ERC-20.\n   * @template TTradeType The type of the trade, either exact in or exact out.\n   * @param routes the routes to swap through and how much of the amount should be routed through each\n   * @param tradeType whether the trade is an exact input or exact output swap\n   * @returns The trade\n   */\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    routes: {\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n      route: MixedRouteSDK<TInput, TOutput>\n    }[],\n    tradeType: TTradeType\n  ): Promise<MixedRouteTrade<TInput, TOutput, TTradeType>> {\n    const populatedRoutes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, amount } of routes) {\n      const amounts: CurrencyAmount<Token>[] = new Array(route.path.length)\n      let inputAmount: CurrencyAmount<TInput>\n      let outputAmount: CurrencyAmount<TOutput>\n\n      invariant(amount.currency.equals(route.input), 'INPUT')\n      inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator)\n      amounts[0] = CurrencyAmount.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator)\n\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pool = route.pools[i]\n        const [outputAmount] = await pool.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n      }\n\n      outputAmount = CurrencyAmount.fromFractionalAmount(\n        route.output,\n        amounts[amounts.length - 1].numerator,\n        amounts[amounts.length - 1].denominator\n      )\n\n      populatedRoutes.push({ route, inputAmount, outputAmount })\n    }\n\n    return new MixedRouteTrade({\n      routes: populatedRoutes,\n      tradeType,\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTrade<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    route: MixedRouteSDK<TInput, TOutput>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade({\n      ...constructorArguments,\n      routes: [\n        {\n          inputAmount: constructorArguments.inputAmount,\n          outputAmount: constructorArguments.outputAmount,\n          route: constructorArguments.route,\n        },\n      ],\n    })\n  }\n\n  /**\n   * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade\n   * elsewhere and do not have any tick data\n   * @template TInput The input token, either Ether or an ERC-20\n   * @template TOutput The output token, either Ether or an ERC-20\n   * @template TTradeType The type of the trade, either exact in or exact out\n   * @param constructorArguments The arguments passed to the trade constructor\n   * @returns The unchecked trade\n   */\n  public static createUncheckedTradeWithMultipleRoutes<\n    TInput extends Currency,\n    TOutput extends Currency,\n    TTradeType extends TradeType\n  >(constructorArguments: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }): MixedRouteTrade<TInput, TOutput, TTradeType> {\n    return new MixedRouteTrade(constructorArguments)\n  }\n\n  /**\n   * Construct a trade by passing in the pre-computed property values\n   * @param routes The routes through which the trade occurs\n   * @param tradeType The type of trade, exact input or exact output\n   */\n  private constructor({\n    routes,\n    tradeType,\n  }: {\n    routes: {\n      route: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }) {\n    const inputCurrency = routes[0].inputAmount.currency\n    const outputCurrency = routes[0].outputAmount.currency\n    invariant(\n      routes.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      routes.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    const numPools = routes.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of routes) {\n      for (const pool of route.pools) {\n        pool instanceof Pool\n          ? poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee))\n          : poolAddressSet.add(Pair.getAddress(pool.token0, pool.token1))\n      }\n    }\n\n    invariant(numPools === poolAddressSet.size, 'POOLS_DUPLICATED')\n\n    invariant(tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    this.swaps = routes\n    this.tradeType = tradeType\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    /// does not support exactOutput, as enforced in the constructor\n    const slippageAdjustedAmountOut = new Fraction(ONE)\n      .add(slippageTolerance)\n      .invert()\n      .multiply(amountOut.quotient).quotient\n    return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    return amountIn\n    /// does not support exactOutput\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  /**\n   * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pools the pools to consider in finding the best trade\n   * @param nextAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\n   * @param currentPools used in recursion; the current list of pools\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   * @returns The exact in trade\n   */\n  public static async bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\n    pools: (Pool | Pair)[],\n    currencyAmountIn: CurrencyAmount<TInput>,\n    currencyOut: TOutput,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPools: (Pool | Pair)[] = [],\n    nextAmountIn: CurrencyAmount<Currency> = currencyAmountIn,\n    bestTrades: MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[] = []\n  ): Promise<MixedRouteTrade<TInput, TOutput, TradeType.EXACT_INPUT>[]> {\n    invariant(pools.length > 0, 'POOLS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(currencyAmountIn === nextAmountIn || currentPools.length > 0, 'INVALID_RECURSION')\n\n    const amountIn = nextAmountIn.wrapped\n    const tokenOut = currencyOut.wrapped\n    for (let i = 0; i < pools.length; i++) {\n      const pool = pools[i]\n      // pool irrelevant\n      if (!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency)) continue\n      if (pool instanceof Pair) {\n        if ((pool as Pair).reserve0.equalTo(ZERO) || (pool as Pair).reserve1.equalTo(ZERO)) continue\n      }\n\n      let amountOut: CurrencyAmount<Token>\n      try {\n        ;[amountOut] = await pool.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        // @ts-ignore[2571] error is unknown\n        if (error.isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.currency.isToken && amountOut.currency.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          await MixedRouteTrade.fromRoute(\n            new MixedRouteSDK([...currentPools, pool], currencyAmountIn.currency, currencyOut),\n            currencyAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pools.length > 1) {\n        const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        await MixedRouteTrade.bestTradeExactIn(\n          poolsExcludingThisPool,\n          currencyAmountIn,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1,\n          },\n          [...currentPools, pool],\n          amountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","export enum Protocol {\n  V2 = 'V2',\n  V3 = 'V3',\n  MIXED = 'MIXED',\n}\n","// entities/route.ts\n\nimport { Route as V2RouteSDK, Pair } from '@uniswap/v2-sdk'\nimport { Route as V3RouteSDK, Pool } from '@uniswap/v3-sdk'\nimport { Protocol } from './protocol'\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\nimport { MixedRouteSDK } from './mixedRoute/route'\n\nexport interface IRoute<TInput extends Currency, TOutput extends Currency, TPool extends Pool | Pair> {\n  protocol: Protocol\n  // array of pools if v3 or pairs if v2\n  pools: TPool[]\n  path: Token[]\n  midPrice: Price<TInput, TOutput>\n  input: TInput\n  output: TOutput\n}\n\n// V2 route wrapper\nexport class RouteV2<TInput extends Currency, TOutput extends Currency>\n  extends V2RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair>\n{\n  public readonly protocol: Protocol = Protocol.V2\n  public readonly pools: Pair[]\n\n  constructor(v2Route: V2RouteSDK<TInput, TOutput>) {\n    super(v2Route.pairs, v2Route.input, v2Route.output)\n    this.pools = this.pairs\n  }\n}\n\n// V3 route wrapper\nexport class RouteV3<TInput extends Currency, TOutput extends Currency>\n  extends V3RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool>\n{\n  public readonly protocol: Protocol = Protocol.V3\n  public readonly path: Token[]\n\n  constructor(v3Route: V3RouteSDK<TInput, TOutput>) {\n    super(v3Route.pools, v3Route.input, v3Route.output)\n    this.path = v3Route.tokenPath\n  }\n}\n\n// Mixed route wrapper\nexport class MixedRoute<TInput extends Currency, TOutput extends Currency>\n  extends MixedRouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool | Pair>\n{\n  public readonly protocol: Protocol = Protocol.MIXED\n\n  constructor(mixedRoute: MixedRouteSDK<TInput, TOutput>) {\n    super(mixedRoute.pools, mixedRoute.input, mixedRoute.output)\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2RouteSDK, Trade as V2TradeSDK } from '@uniswap/v2-sdk'\nimport { Pool, Route as V3RouteSDK, Trade as V3TradeSDK } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ONE_HUNDRED_PERCENT, ZERO, ZERO_PERCENT } from '../constants'\nimport { MixedRouteSDK } from './mixedRoute/route'\nimport { MixedRouteTrade as MixedRouteTradeSDK } from './mixedRoute/trade'\nimport { IRoute, MixedRoute, RouteV2, RouteV3 } from './route'\n\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  public readonly routes: IRoute<TInput, TOutput, Pair | Pool>[]\n  public readonly tradeType: TTradeType\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade. May consist of swaps in v2 or v3.\n   */\n  public readonly swaps: {\n    route: IRoute<TInput, TOutput, Pair | Pool>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  public constructor({\n    v2Routes,\n    v3Routes,\n    tradeType,\n    mixedRoutes,\n  }: {\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n  }) {\n    this.swaps = []\n    this.routes = []\n    // wrap v2 routes\n    for (const { routev2, inputAmount, outputAmount } of v2Routes) {\n      const route = new RouteV2(routev2)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v3 routes\n    for (const { routev3, inputAmount, outputAmount } of v3Routes) {\n      const route = new RouteV3(routev3)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap mixedRoutes\n    if (mixedRoutes) {\n      for (const { mixedRoute, inputAmount, outputAmount } of mixedRoutes) {\n        const route = new MixedRoute(mixedRoute)\n        this.routes.push(route)\n        this.swaps.push({\n          route,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n\n    if (this.swaps.length === 0) {\n      throw new Error('No routes provided when calling Trade constructor')\n    }\n\n    this.tradeType = tradeType\n\n    // each route must have the same input and output currency\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    invariant(\n      this.swaps.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      this.swaps.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    // pools must be unique inter protocols\n    const numPools = this.swaps.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of this.swaps) {\n      for (const pool of route.pools) {\n        if (pool instanceof Pool) {\n          poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, (pool as Pool).fee))\n        } else if (pool instanceof Pair) {\n          const pair = pool\n          poolAddressSet.add(Pair.getAddress(pair.token0, pair.token1))\n        } else {\n          throw new Error('Unexpected pool type in route when constructing trade object')\n        }\n      }\n    }\n    invariant(numPools === poolAddressSet.size, 'POOLS_DUPLICATED')\n  }\n\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * Returns the sell tax of the input token\n   */\n  public get inputTax(): Percent {\n    const inputCurrency = this.inputAmount.currency\n    if (inputCurrency.isNative || !inputCurrency.wrapped.sellFeeBps) return ZERO_PERCENT\n\n    return new Percent(inputCurrency.wrapped.sellFeeBps.toNumber(), 10000)\n  }\n\n  /**\n   * Returns the buy tax of the output token\n   */\n  public get outputTax(): Percent {\n    const outputCurrency = this.outputAmount.currency\n    if (outputCurrency.isNative || !outputCurrency.wrapped.buyFeeBps) return ZERO_PERCENT\n\n    return new Percent(outputCurrency.wrapped.buyFeeBps.toNumber(), 10000)\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n  /**\n   * Returns the percent difference between the route's mid price and the expected execution price\n   * In order to exclude token taxes from the price impact calculation, the spot price is calculated\n   * using a ratio of values that go into the pools, which are the post-tax input amount and pre-tax output amount.\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    // returns 0% price impact even though this may be inaccurate as a swap may have occured.\n    // because we're unable to derive the pre-buy-tax amount, use 0% as a placeholder.\n    if (this.outputTax.equalTo(ONE_HUNDRED_PERCENT)) return ZERO_PERCENT\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      const postTaxInputAmount = inputAmount.multiply(new Fraction(ONE).subtract(this.inputTax))\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(postTaxInputAmount))\n    }\n\n    // if the total output of this trade is 0, then most likely the post-tax input was also 0, and therefore this swap\n    // does not move the pools' market price\n    if (spotOutputAmount.equalTo(ZERO)) return ZERO_PERCENT\n\n    const preTaxOutputAmount = this.outputAmount.divide(new Fraction(ONE).subtract(this.outputTax))\n    const priceImpact = spotOutputAmount.subtract(preTaxOutputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return amountOut\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(amountOut.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return amountIn\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    tradeType: TTradeType,\n    mixedRoutes?: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[]\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    const populatedV2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedMixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    for (const { routev2, amount } of v2Routes) {\n      const v2Trade = new V2TradeSDK(routev2, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n\n      populatedV2Routes.push({\n        routev2,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev3, amount } of v3Routes) {\n      const v3Trade = await V3TradeSDK.fromRoute(routev3, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n\n      populatedV3Routes.push({\n        routev3,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    if (mixedRoutes) {\n      for (const { mixedRoute, amount } of mixedRoutes) {\n        const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(mixedRoute, amount, tradeType)\n        const { inputAmount, outputAmount } = mixedRouteTrade\n\n        populatedMixedRoutes.push({\n          mixedRoute,\n          inputAmount,\n          outputAmount,\n        })\n      }\n    }\n\n    return new Trade({\n      v2Routes: populatedV2Routes,\n      v3Routes: populatedV3Routes,\n      mixedRoutes: populatedMixedRoutes,\n      tradeType,\n    })\n  }\n\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: V2RouteSDK<TInput, TOutput> | V3RouteSDK<TInput, TOutput> | MixedRouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    let v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    let mixedRoutes: {\n      mixedRoute: MixedRouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    if (route instanceof V2RouteSDK) {\n      const v2Trade = new V2TradeSDK(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n      v2Routes = [{ routev2: route, inputAmount, outputAmount }]\n    } else if (route instanceof V3RouteSDK) {\n      const v3Trade = await V3TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n      v3Routes = [{ routev3: route, inputAmount, outputAmount }]\n    } else if (route instanceof MixedRouteSDK) {\n      const mixedRouteTrade = await MixedRouteTradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = mixedRouteTrade\n      mixedRoutes = [{ mixedRoute: route, inputAmount, outputAmount }]\n    } else {\n      throw new Error('Invalid route type')\n    }\n\n    return new Trade({\n      v2Routes,\n      v3Routes,\n      mixedRoutes,\n      tradeType,\n    })\n  }\n}\n","import { pack } from '@ethersproject/solidity'\nimport { Currency, Token } from '@uniswap/sdk-core'\nimport { Pool } from '@uniswap/v3-sdk'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\nimport { V2_FEE_PATH_PLACEHOLDER } from '../constants'\n\n/**\n * Converts a route to a hex encoded path\n * @notice only supports exactIn route encodings\n * @param route the mixed path to convert to an encoded path\n * @returns the exactIn encoded path\n */\nexport function encodeMixedRouteToPath(route: MixedRouteSDK<Currency, Currency>): string {\n  const firstInputToken: Token = route.input.wrapped\n\n  const { path, types } = route.pools.reduce(\n    (\n      { inputToken, path, types }: { inputToken: Token; path: (string | number)[]; types: string[] },\n      pool: Pool | Pair,\n      index\n    ): { inputToken: Token; path: (string | number)[]; types: string[] } => {\n      const outputToken: Token = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      if (index === 0) {\n        return {\n          inputToken: outputToken,\n          types: ['address', 'uint24', 'address'],\n          path: [inputToken.address, pool instanceof Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.address],\n        }\n      } else {\n        return {\n          inputToken: outputToken,\n          types: [...types, 'uint24', 'address'],\n          path: [...path, pool instanceof Pool ? pool.fee : V2_FEE_PATH_PLACEHOLDER, outputToken.address],\n        }\n      }\n    },\n    { inputToken: firstInputToken, path: [], types: [] }\n  )\n\n  return pack(types, path)\n}\n","import { Currency, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport { Pool } from '@uniswap/v3-sdk'\nimport { MixedRouteSDK } from '../entities/mixedRoute/route'\n\n/**\n * Utility function to return each consecutive section of Pools or Pairs in a MixedRoute\n * @param route\n * @returns a nested array of Pools or Pairs in the order of the route\n */\nexport const partitionMixedRouteByProtocol = (route: MixedRouteSDK<Currency, Currency>): (Pool | Pair)[][] => {\n  let acc = []\n\n  let left = 0\n  let right = 0\n  while (right < route.pools.length) {\n    if (\n      (route.pools[left] instanceof Pool && route.pools[right] instanceof Pair) ||\n      (route.pools[left] instanceof Pair && route.pools[right] instanceof Pool)\n    ) {\n      acc.push(route.pools.slice(left, right))\n      left = right\n    }\n    // seek forward with right pointer\n    right++\n    if (right === route.pools.length) {\n      /// we reached the end, take the rest\n      acc.push(route.pools.slice(left, right))\n    }\n  }\n  return acc\n}\n\n/**\n * Simple utility function to get the output of an array of Pools or Pairs\n * @param pools\n * @param firstInputToken\n * @returns the output token of the last pool in the array\n */\nexport const getOutputOfPools = (pools: (Pool | Pair)[], firstInputToken: Token): Token => {\n  const { inputToken: outputToken } = pools.reduce(\n    ({ inputToken }, pool: Pool | Pair): { inputToken: Token } => {\n      if (!pool.involvesToken(inputToken)) throw new Error('PATH')\n      const outputToken: Token = pool.token0.equals(inputToken) ? pool.token1 : pool.token0\n      return {\n        inputToken: outputToken,\n      }\n    },\n    { inputToken: firstInputToken }\n  )\n  return outputToken\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Percent, TradeType, validateAndParseAddress, WETH9 } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport {\n  encodeRouteToPath,\n  FeeOptions,\n  MethodParameters,\n  Payments,\n  PermitOptions,\n  Pool,\n  Position,\n  SelfPermit,\n  toHex,\n  Trade as V3Trade,\n} from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { ADDRESS_THIS, MSG_SENDER } from './constants'\nimport { ApproveAndCall, ApprovalTypes, CondensedAddLiquidityOptions } from './approveAndCall'\nimport { Trade } from './entities/trade'\nimport { Protocol } from './entities/protocol'\nimport { MixedRoute, RouteV2, RouteV3 } from './entities/route'\nimport { MulticallExtended, Validation } from './multicallExtended'\nimport { PaymentsExtended } from './paymentsExtended'\nimport { MixedRouteTrade } from './entities/mixedRoute/trade'\nimport { encodeMixedRouteToPath } from './utils/encodeMixedRouteToPath'\nimport { MixedRouteSDK } from './entities/mixedRoute/route'\nimport { partitionMixedRouteByProtocol, getOutputOfPools } from './utils'\n\nconst ZERO = JSBI.BigInt(0)\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output. If omitted, output is sent to msg.sender.\n   */\n  recipient?: string\n\n  /**\n   * Either deadline (when the transaction expires, in epoch seconds), or previousBlockhash.\n   */\n  deadlineOrPreviousBlockhash?: Validation\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\nexport interface SwapAndAddOptions extends SwapOptions {\n  /**\n   * The optional permit parameters for pulling in remaining output token.\n   */\n  outputTokenPermit?: PermitOptions\n}\n\ntype AnyTradeType =\n  | Trade<Currency, Currency, TradeType>\n  | V2Trade<Currency, Currency, TradeType>\n  | V3Trade<Currency, Currency, TradeType>\n  | MixedRouteTrade<Currency, Currency, TradeType>\n  | (\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    )[]\n\n/**\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * @notice Generates the calldata for a Swap with a V2 Route.\n   * @param trade The V2Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV2Swap(\n    trade: V2Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string {\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const path = trade.route.path.map((token) => token.address)\n    const recipient = routerMustCustody\n      ? ADDRESS_THIS\n      : typeof options.recipient === 'undefined'\n      ? MSG_SENDER\n      : validateAndParseAddress(options.recipient)\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams)\n    } else {\n      const exactOutputParams = [amountOut, amountIn, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams)\n    }\n  }\n\n  /**\n   * @notice Generates the calldata for a Swap with a V3 Route.\n   * @param trade The V3Trade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeV3Swap(\n    trade: V3Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      if (singleHop) {\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n        }\n      } else {\n        const path: string = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputParams = {\n            path,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n        } else {\n          const exactOutputParams = {\n            path,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  /**\n   * @notice Generates the calldata for a MixedRouteSwap. Since single hop routes are not MixedRoutes, we will instead generate\n   *         them via the existing encodeV3Swap and encodeV2Swap methods.\n   * @param trade The MixedRouteTrade to encode.\n   * @param options SwapOptions to use for the trade.\n   * @param routerMustCustody Flag for whether funds should be sent to the router\n   * @param performAggregatedSlippageCheck Flag for whether we want to perform an aggregated slippage check\n   * @returns A string array of calldatas for the trade.\n   */\n  private static encodeMixedRouteSwap(\n    trade: MixedRouteTrade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    invariant(trade.tradeType === TradeType.EXACT_INPUT, 'TRADE_TYPE')\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n        return route.pools.every((pool) => pool instanceof Pool)\n      }\n\n      if (singleHop) {\n        /// For single hop, since it isn't really a mixedRoute, we'll just mimic behavior of V3 or V2\n        /// We don't use encodeV3Swap() or encodeV2Swap() because casting the trade to a V3Trade or V2Trade is overcomplex\n        if (mixedRouteIsAllV3(route)) {\n          const exactInputSingleParams = {\n            tokenIn: route.path[0].address,\n            tokenOut: route.path[1].address,\n            fee: (route.pools as Pool[])[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const path = route.path.map((token) => token.address)\n\n          const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n        }\n      } else {\n        const sections = partitionMixedRouteByProtocol(route)\n\n        const isLastSectionInRoute = (i: number) => {\n          return i === sections.length - 1\n        }\n\n        let outputToken\n        let inputToken = route.input.wrapped\n\n        for (let i = 0; i < sections.length; i++) {\n          const section = sections[i]\n          /// Now, we get output of this section\n          outputToken = getOutputOfPools(section, inputToken)\n\n          const newRouteOriginal = new MixedRouteSDK(\n            [...section],\n            section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n            outputToken\n          )\n          const newRoute = new MixedRoute(newRouteOriginal)\n\n          /// Previous output is now input\n          inputToken = outputToken\n\n          if (mixedRouteIsAllV3(newRoute)) {\n            const path: string = encodeMixedRouteToPath(newRoute)\n            const exactInputParams = {\n              path,\n              // By default router holds funds until the last swap, then it is sent to the recipient\n              // special case exists where we are unwrapping WETH output, in which case `routerMustCustody` is set to true\n              // and router still holds the funds. That logic bundled into how the value of `recipient` is calculated\n              recipient: isLastSectionInRoute(i) ? recipient : ADDRESS_THIS,\n              amountIn: i === 0 ? amountIn : 0,\n              amountOutMinimum: !isLastSectionInRoute(i) ? 0 : amountOut,\n            }\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n          } else {\n            const exactInputParams = [\n              i === 0 ? amountIn : 0, // amountIn\n              !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n              newRoute.path.map((token) => token.address), // path\n              isLastSectionInRoute(i) ? recipient : ADDRESS_THIS, // to\n            ]\n\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams))\n          }\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  private static encodeSwaps(\n    trades: AnyTradeType,\n    options: SwapOptions,\n    isSwapAndAdd?: boolean\n  ): {\n    calldatas: string[]\n    sampleTrade:\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n    routerMustCustody: boolean\n    inputIsNative: boolean\n    outputIsNative: boolean\n    totalAmountIn: CurrencyAmount<Currency>\n    minimumAmountOut: CurrencyAmount<Currency>\n    quoteAmountOut: CurrencyAmount<Currency>\n  } {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual trade objects.\n    if (trades instanceof Trade) {\n      invariant(\n        trades.swaps.every(\n          (swap) =>\n            swap.route.protocol === Protocol.V3 ||\n            swap.route.protocol === Protocol.V2 ||\n            swap.route.protocol === Protocol.MIXED\n        ),\n        'UNSUPPORTED_PROTOCOL'\n      )\n\n      let individualTrades: (\n        | V2Trade<Currency, Currency, TradeType>\n        | V3Trade<Currency, Currency, TradeType>\n        | MixedRouteTrade<Currency, Currency, TradeType>\n      )[] = []\n\n      for (const { route, inputAmount, outputAmount } of trades.swaps) {\n        if (route.protocol === Protocol.V2) {\n          individualTrades.push(\n            new V2Trade(\n              route as RouteV2<Currency, Currency>,\n              trades.tradeType === TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n              trades.tradeType\n            )\n          )\n        } else if (route.protocol === Protocol.V3) {\n          individualTrades.push(\n            V3Trade.createUncheckedTrade({\n              route: route as RouteV3<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else if (route.protocol === Protocol.MIXED) {\n          individualTrades.push(\n            /// we can change the naming of this function on MixedRouteTrade if needed\n            MixedRouteTrade.createUncheckedTrade({\n              route: route as MixedRoute<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        } else {\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n        }\n      }\n      trades = individualTrades\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades]\n    }\n\n    const numberOfTrades = trades.reduce(\n      (numberOfTrades, trade) =>\n        numberOfTrades + (trade instanceof V3Trade || trade instanceof MixedRouteTrade ? trade.swaps.length : 1),\n      0\n    )\n\n    const sampleTrade = trades[0]\n\n    // All trades should have the same starting/ending currency and trade type\n    invariant(\n      trades.every((trade) => trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency)),\n      'TOKEN_IN_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency)),\n      'TOKEN_OUT_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.tradeType === sampleTrade.tradeType),\n      'TRADE_TYPE_DIFF'\n    )\n\n    const calldatas: string[] = []\n\n    const inputIsNative = sampleTrade.inputAmount.currency.isNative\n    const outputIsNative = sampleTrade.outputAmount.currency.isNative\n\n    // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck = sampleTrade.tradeType === TradeType.EXACT_INPUT && numberOfTrades > 2\n    // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n    const routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    for (const trade of trades) {\n      if (trade instanceof V2Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck))\n      } else if (trade instanceof V3Trade) {\n        for (const calldata of SwapRouter.encodeV3Swap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else if (trade instanceof MixedRouteTrade) {\n        for (const calldata of SwapRouter.encodeMixedRouteSwap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      } else {\n        throw new Error('Unsupported trade object')\n      }\n    }\n\n    const ZERO_IN: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0)\n    const ZERO_OUT: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0)\n\n    const minimumAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)),\n      ZERO_OUT\n    )\n\n    const quoteAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.outputAmount),\n      ZERO_OUT\n    )\n\n    const totalAmountIn: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)),\n      ZERO_IN\n    )\n\n    return {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n      quoteAmountOut,\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n      | (\n          | V2Trade<Currency, Currency, TradeType>\n          | V3Trade<Currency, Currency, TradeType>\n          | MixedRouteTrade<Currency, Currency, TradeType>\n        )[],\n    options: SwapOptions\n  ): MethodParameters {\n    const {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options)\n\n    // unwrap or sweep\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee))\n      } else {\n        calldatas.push(\n          PaymentsExtended.encodeSweepToken(\n            sampleTrade.outputAmount.currency.wrapped,\n            minimumAmountOut.quotient,\n            options.recipient,\n            options.fee\n          )\n        )\n      }\n    }\n\n    // must refund when paying in ETH: either with an uncertain input amount OR if there's a chance of a partial fill.\n    // unlike ERC20's, the full ETH value must be sent in the transaction, so the rest must be refunded.\n    if (inputIsNative && (sampleTrade.tradeType === TradeType.EXACT_OUTPUT || SwapRouter.riskOfPartialFill(trades))) {\n      calldatas.push(Payments.encodeRefundETH())\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: toHex(inputIsNative ? totalAmountIn.quotient : ZERO),\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapAndAddCallParameters(\n    trades: AnyTradeType,\n    options: SwapAndAddOptions,\n    position: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    tokenInApprovalType: ApprovalTypes,\n    tokenOutApprovalType: ApprovalTypes\n  ): MethodParameters {\n    const {\n      calldatas,\n      inputIsNative,\n      outputIsNative,\n      sampleTrade,\n      totalAmountIn: totalAmountSwapped,\n      quoteAmountOut,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options, true)\n\n    // encode output token permit if necessary\n    if (options.outputTokenPermit) {\n      invariant(quoteAmountOut.currency.isToken, 'NON_TOKEN_PERMIT_OUTPUT')\n      calldatas.push(SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit))\n    }\n\n    const chainId = sampleTrade.route.chainId\n    const zeroForOne = position.pool.token0.wrapped.address === totalAmountSwapped.currency.wrapped.address\n    const { positionAmountIn, positionAmountOut } = SwapRouter.getPositionAmounts(position, zeroForOne)\n\n    // if tokens are native they will be converted to WETH9\n    const tokenIn = inputIsNative ? WETH9[chainId] : positionAmountIn.currency.wrapped\n    const tokenOut = outputIsNative ? WETH9[chainId] : positionAmountOut.currency.wrapped\n\n    // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n    const amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped)\n    if (amountOutRemaining.greaterThan(CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative\n        ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient))\n        : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient))\n    }\n\n    // if input is native, convert to WETH9, else pull ERC20 token\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient))\n      : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient))\n\n    // approve token balances to NFTManager\n    if (tokenInApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType))\n    if (tokenOutApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType))\n\n    // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n    const minimalPosition = Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false,\n    })\n\n    // encode NFTManager add liquidity\n    calldatas.push(\n      ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)\n    )\n\n    // sweep remaining tokens\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO))\n    outputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO))\n\n    let value: JSBI\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient\n    } else {\n      value = ZERO\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString(),\n    }\n  }\n\n  // if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\n  private static riskOfPartialFill(trades: AnyTradeType): boolean {\n    if (Array.isArray(trades)) {\n      return trades.some((trade) => {\n        return SwapRouter.v3TradeWithHighPriceImpact(trade)\n      })\n    } else {\n      return SwapRouter.v3TradeWithHighPriceImpact(trades)\n    }\n  }\n\n  private static v3TradeWithHighPriceImpact(\n    trade:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | MixedRouteTrade<Currency, Currency, TradeType>\n  ): boolean {\n    return !(trade instanceof V2Trade) && trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n  }\n\n  private static getPositionAmounts(\n    position: Position,\n    zeroForOne: boolean\n  ): {\n    positionAmountIn: CurrencyAmount<Currency>\n    positionAmountOut: CurrencyAmount<Currency>\n  } {\n    const { amount0, amount1 } = position.mintAmounts\n    const currencyAmount0 = CurrencyAmount.fromRawAmount(position.pool.token0, amount0)\n    const currencyAmount1 = CurrencyAmount.fromRawAmount(position.pool.token1, amount1)\n\n    const [positionAmountIn, positionAmountOut] = zeroForOne\n      ? [currencyAmount0, currencyAmount1]\n      : [currencyAmount1, currencyAmount0]\n    return { positionAmountIn, positionAmountOut }\n  }\n}\n"],"names":["MSG_SENDER","ADDRESS_THIS","ZERO","JSBI","BigInt","ONE","V2_FEE_PATH_PLACEHOLDER","ZERO_PERCENT","Percent","ONE_HUNDRED_PERCENT","ApprovalTypes","isMint","options","Object","keys","some","k","ApproveAndCall","encodeApproveMax","token","INTERFACE","encodeFunctionData","address","encodeApproveMaxMinusOne","encodeApproveZeroThenMax","encodeApproveZeroThenMaxMinusOne","encodeCallPositionManager","calldatas","length","process","invariant","encodedMulticall","NonfungiblePositionManager","encodeAddLiquidity","position","minimalPosition","addLiquidityOptions","slippageTolerance","_position$mintAmounts","mintAmountsWithSlippage","amount0Min","amount0","amount1Min","amount1","lessThan","quotient","token0","pool","token1","fee","tickLower","tickUpper","toHex","recipient","tokenId","encodeApprove","approvalType","MAX","wrapped","MAX_MINUS_ONE","ZERO_THEN_MAX","ZERO_THEN_MAX_MINUS_ONE","Error","Interface","abi","validateAndParseBytes32","bytes32","match","toLowerCase","MulticallExtended","encodeMulticall","validation","Multicall","Array","isArray","startsWith","previousBlockhash","deadline","encodeFeeBips","multiply","PaymentsExtended","encodeUnwrapWETH9","amountMinimum","feeOptions","Payments","feeBips","feeRecipient","validateAndParseAddress","encodeSweepToken","encodePull","amount","encodeWrapETH","MixedRouteSDK","pools","input","output","chainId","allOnSameChain","every","wrappedInput","involvesToken","tokenPath","_iterator","_createForOfIteratorHelperLoose","entries","_step","done","_step$value","value","i","currentInputToken","equals","nextToken","push","path","_createClass","key","get","_midPrice","price","slice","reduce","_ref","nextInput","token0Price","token1Price","Price","denominator","numerator","tradeComparator","a","b","inputAmount","currency","outputAmount","equalTo","aHops","swaps","total","cur","route","bHops","MixedRouteTrade","routes","tradeType","inputCurrency","outputCurrency","_ref2","_ref3","numPools","map","_ref4","poolAddressSet","Set","_iterator2","_step2","Pool","add","getAddress","Pair","size","TradeType","EXACT_INPUT","fromRoute","_fromRoute","_asyncToGenerator","_regeneratorRuntime","mark","_callee","amounts","_yield$pool$getOutput","_outputAmount","wrap","_callee$","_context","prev","next","getOutputAmount","sent","CurrencyAmount","fromFractionalAmount","abrupt","stop","_x","_x2","_x3","apply","arguments","fromRoutes","_fromRoutes","_callee2","populatedRoutes","_iterator3","_step3","_step3$value","_yield$pool$getOutput2","_outputAmount2","_callee2$","_context2","_x4","_x5","createUncheckedTrade","constructorArguments","_extends","createUncheckedTradeWithMultipleRoutes","_proto","prototype","minimumAmountOut","amountOut","slippageAdjustedAmountOut","Fraction","invert","fromRawAmount","maximumAmountIn","amountIn","worstExecutionPrice","bestTradeExactIn","_bestTradeExactIn","_callee3","currencyAmountIn","currencyOut","_temp","currentPools","nextAmountIn","bestTrades","_ref5$maxNumResults","_ref5","maxNumResults","_ref5$maxHops","maxHops","tokenOut","_context3","reserve0","reserve1","_yield$pool$getOutput3","t0","isInsufficientInputAmountError","isToken","t1","sortedInsert","t2","concat","t3","t4","t5","poolsExcludingThisPool","_x6","_x7","_x8","_x9","_x10","_x11","_x12","_inputAmount","totalInputFromRoutes","_ref6","totalOutputFromRoutes","_ref7","_this$_executionPrice","_executionPrice","_priceImpact","spotOutputAmount","_iterator4","_step4","_step4$value","midPrice","quote","priceImpact","subtract","divide","Protocol","RouteV2","_V2RouteSDK","_inheritsLoose","v2Route","_this","call","pairs","V2","V2RouteSDK","RouteV3","_V3RouteSDK","v3Route","_this2","V3","V3RouteSDK","MixedRoute","_MixedRouteSDK","mixedRoute","_this3","MIXED","Trade","v2Routes","v3Routes","mixedRoutes","routev2","_step2$value","routev3","_iterator5","_step5","pair","EXACT_OUTPUT","slippageAdjustedAmountIn","populatedV2Routes","populatedV3Routes","populatedMixedRoutes","_iterator6","_step6","_step6$value","_amount","v2Trade","_inputAmount3","_outputAmount3","_iterator7","_step7","_step7$value","_amount2","v3Trade","_inputAmount4","_outputAmount4","_iterator8","_step8","_step8$value","mixedRouteTrade","V2TradeSDK","V3TradeSDK","MixedRouteTradeSDK","_inputAmount5","_outputAmount5","_inputAmount6","_outputAmount6","isNative","sellFeeBps","toNumber","buyFeeBps","outputTax","_iterator9","_step9","_step9$value","postTaxInputAmount","inputTax","preTaxOutputAmount","encodeMixedRouteToPath","firstInputToken","_route$pools$reduce","index","inputToken","types","outputToken","pack","partitionMixedRouteByProtocol","acc","left","right","getOutputOfPools","_pools$reduce","REFUND_ETH_PRICE_IMPACT_THRESHOLD","SwapRouter","encodeV2Swap","trade","routerMustCustody","performAggregatedSlippageCheck","exactInputParams","exactOutputParams","encodeV3Swap","singleHop","exactInputSingleParams","tokenIn","amountOutMinimum","sqrtPriceLimitX96","exactOutputSingleParams","amountInMaximum","encodeRouteToPath","encodeMixedRouteSwap","_loop","mixedRouteIsAllV3","sections","isLastSectionInRoute","section","newRouteOriginal","newRoute","encodeSwaps","trades","isSwapAndAdd","swap","protocol","individualTrades","V2Trade","V3Trade","numberOfTrades","sampleTrade","inputIsNative","outputIsNative","inputTokenPermit","SelfPermit","encodePermit","calldata","ZERO_IN","ZERO_OUT","sum","quoteAmountOut","totalAmountIn","swapCallParameters","_SwapRouter$encodeSwa","riskOfPartialFill","encodeRefundETH","deadlineOrPreviousBlockhash","swapAndAddCallParameters","tokenInApprovalType","tokenOutApprovalType","_SwapRouter$encodeSwa2","totalAmountSwapped","outputTokenPermit","zeroForOne","_SwapRouter$getPositi","getPositionAmounts","positionAmountIn","positionAmountOut","WETH9","amountOutRemaining","greaterThan","NOT_REQUIRED","Position","fromAmounts","toString","useFullPrecision","v3TradeWithHighPriceImpact","mintAmounts","currencyAmount0","currencyAmount1"],"mappings":"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"}